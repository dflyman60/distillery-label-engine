// src/routes/labels.js  (CommonJS)
const express = require("express")
const db = require("../db")
const pool = require("../db")


console.log("pool ready:", typeof pool?.connect === "function")

const router = express.Router()

function wizardOnly(req, res, next) {
  const key = req.get("x-wizard-key")
  const expected = process.env.WIZARD_KEY

  if (!expected) {
    return res.status(500).json({ error: "Server misconfigured: WIZARD_KEY not set" })
  }
  if (!key || key !== expected) {
    return res.status(403).json({ error: "Wizard-only endpoint" })
  }
  next()
}

const FORBIDDEN_CONTENT_FIELDS = new Set([
  "frontLabel",
  "backLabel",
  "complianceBlock",
  "brief",
  "front_label",
  "back_label",
  "compliance_block",
])

const ALLOWED_METADATA_FIELDS = new Set([
  "internalNotes",
  "status",
  "tags",
  "ttbTrackingNumber",
  "ttbApplicationId",
])

function hasForbiddenContent(body) {
  for (const k of Object.keys(body || {})) {
    if (FORBIDDEN_CONTENT_FIELDS.has(k)) return k
  }
  return null
}

function pickAllowedMetadata(body) {
  const out = {}
  for (const k of Object.keys(body || {})) {
    if (ALLOWED_METADATA_FIELDS.has(k)) out[k] = body[k]
  }
  return out
}

router.get("/labels/:labelId", async (req, res) => {
  const { labelId } = req.params
  try {
    const q = await pool.query(
      `
      SELECT
        l.*,
        h.id            AS history_id,
        h.action        AS history_action,
        h.created_at    AS history_created_at,
        h.brand_name    AS brand_name,
        h.product_name  AS product_name,
        h.spirit_type   AS spirit_type,
        h.abv           AS abv,
        h.volume_ml     AS volume_ml,
        h.brief         AS brief,
        h.front_label   AS front_label,
        h.back_label    AS back_label,
        h.compliance_block AS compliance_block
      FROM labels l
      LEFT JOIN label_history h
        ON h.id = l.current_history_id
      WHERE l.id = $1
      `,
      [labelId]
    )

    if (q.rows.length === 0) return res.status(404).json({ error: "Label not found" })

    const row = q.rows[0]

    const label = { ...row }
    delete label.history_id
    delete label.history_action
    delete label.history_created_at
    delete label.brand_name
    delete label.product_name
    delete label.spirit_type
    delete label.abv
    delete label.volume_ml
    delete label.brief
    delete label.front_label
    delete label.back_label
    delete label.compliance_block

    const currentVersion =
      row.history_id == null
        ? null
        : {
            id: row.history_id,
            action: row.history_action,
            createdAt: row.history_created_at,
            brandName: row.brand_name,
            productName: row.product_name,
            spiritType: row.spirit_type,
            abv: row.abv,
            volumeMl: row.volume_ml,
            brief: row.brief,
            frontLabel: row.front_label,
            backLabel: row.back_label,
            complianceBlock: row.compliance_block,
          }

    return res.json({ ok: true, label, currentVersion })
  } catch (err) {
    return res.status(500).json({ error: "Failed to load label", detail: String(err?.message || err) })
  }
})

router.get("/labels/:labelId/history", async (req, res) => {
  const { labelId } = req.params
  const limit = Math.min(Number(req.query.limit || 50), 250)

  try {
    const q = await pool.query(
      `
      SELECT
        id,
        label_id,
        action,
        brand_name,
        product_name,
        spirit_type,
        abv,
        volume_ml,
        brief,
        front_label,
        back_label,
        compliance_block,
        created_at
      FROM label_history
      WHERE label_id = $1
      ORDER BY created_at DESC, id DESC
      LIMIT $2
      `,
      [labelId, limit]
    )

    const versions = q.rows.map((r) => ({
      id: r.id,
      labelId: r.label_id,
      action: r.action,
      brandName: r.brand_name,
      productName: r.product_name,
      spiritType: r.spirit_type,
      abv: r.abv,
      volumeMl: r.volume_ml,
      brief: r.brief,
      frontLabel: r.front_label,
      backLabel: r.back_label,
      complianceBlock: r.compliance_block,
      createdAt: r.created_at,
    }))

    return res.json({ ok: true, versions })
  } catch (err) {
    return res.status(500).json({ error: "Failed to load history", detail: String(err?.message || err) })
  }
})

router.post("/labels/:labelId/wizard/save", wizardOnly, async (req, res) => {
  const { labelId } = req.params
  const body = req.body || {}

  const productName = body.productName
  const frontLabel = body.frontLabel
  const backLabel = body.backLabel
  const complianceBlock = body.complianceBlock

  if (!productName || !frontLabel || !backLabel || !complianceBlock) {
    return res.status(400).json({
      error: "Missing required fields: productName, frontLabel, backLabel, complianceBlock",
    })
  }

  const brandName = body.brandName ?? null
  const spiritType = body.spiritType ?? null
  const abv = body.abv ?? null
  const volumeMl = body.volumeMl ?? null
  const brief = body.brief ?? null

  const client = await pool.connect()
  try {
    await client.query("BEGIN")

    await client.query(
      `INSERT INTO labels (id) VALUES ($1) ON CONFLICT (id) DO NOTHING`,
      [labelId]
    )

    const cur = await client.query(`SELECT current_history_id FROM labels WHERE id = $1`, [labelId])
    const currentHistoryId = cur.rows?.[0]?.current_history_id ?? null
    const action = currentHistoryId ? "UPDATE" : "CREATE"

    const insertHistory = await client.query(
      `
      INSERT INTO label_history (
        label_id, action, brand_name, product_name, spirit_type, abv, volume_ml,
        brief, front_label, back_label, compliance_block
      )
      VALUES ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11)
      RETURNING
        id, label_id, action, brand_name, product_name, spirit_type, abv, volume_ml,
        brief, front_label, back_label, compliance_block, created_at
      `,
      [
        labelId,
        action,
        brandName,
        productName,
        spiritType,
        abv,
        volumeMl,
        brief,
        frontLabel,
        backLabel,
        complianceBlock,
      ]
    )

    const v = insertHistory.rows[0]

    await client.query(
      `UPDATE labels SET current_history_id = $2 WHERE id = $1`,
      [labelId, v.id]
    )

    await client.query("COMMIT")

    return res.json({
      ok: true,
      version: {
        id: v.id,
        labelId: v.label_id,
        action: v.action,
        brandName: v.brand_name,
        productName: v.product_name,
        spiritType: v.spirit_type,
        abv: v.abv,
        volumeMl: v.volume_ml,
        brief: v.brief,
        frontLabel: v.front_label,
        backLabel: v.back_label,
        complianceBlock: v.compliance_block,
        createdAt: v.created_at,
      },
    })
  } catch (err) {
    await client.query("ROLLBACK")
    return res.status(500).json({ error: "Wizard save failed", detail: String(err?.message || err) })
  } finally {
    client.release()
  }
})

router.patch("/labels/:labelId", async (req, res) => {
  const { labelId } = req.params
  const body = req.body || {}

  const forbidden = hasForbiddenContent(body)
  if (forbidden) {
    return res.status(403).json({
      error: "Label content is wizard-only and versioned via label_history",
      field: forbidden,
    })
  }

  const meta = pickAllowedMetadata(body)
  const keys = Object.keys(meta)

  if (keys.length === 0) {
    return res.json({ ok: true, updated: false, reason: "No allowed fields" })
  }

  const mapKey = (k) => {
    if (k === "internalNotes") return "internal_notes"
    if (k === "ttbTrackingNumber") return "ttb_tracking_number"
    if (k === "ttbApplicationId") return "ttb_application_id"
    return k
  }

  const setClauses = []
  const values = [labelId]
  let idx = 2

  for (const k of keys) {
    setClauses.push(`${mapKey(k)} = $${idx++}`)
    values.push(meta[k])
  }

  try {
    await pool.query(`INSERT INTO labels (id) VALUES ($1) ON CONFLICT (id) DO NOTHING`, [labelId])

    const q = await pool.query(
      `UPDATE labels SET ${setClauses.join(", ")} WHERE id = $1 RETURNING *`,
      values
    )

    return res.json({ ok: true, updated: true, label: q.rows[0] })
  } catch (err) {
    return res.status(500).json({ error: "Metadata update failed", detail: String(err?.message || err) })
  }
})

module.exports = router

